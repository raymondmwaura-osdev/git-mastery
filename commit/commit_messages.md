# Writing Clear and Effective Git Commit Messages

## Introduction

When you use Git to manage version control, each commit represents a change set. The commit message is the primary human-readable description of that change. A well-written commit message helps others (and future you) understand **what** changed and **why**, without digging immediately into the code diff. Poor messages degrade readability, increase onboarding cost, hinder maintenance, etc.

This document describes:

* the importance of good commit messages;
* a recommended structure and tone;
* concrete rules and guidelines;
* examples;
* additional notes and caveats.

---

## Why commit message quality matters

### Communication tool

Git history is not only for machines; it is a communication channel between developers. A commit message becomes part of the project’s narrative: what changed, when, by whom, and why.

### Maintenance and debugging

When you (or someone else) inspect logs months later to understand how a behaviour changed, good commit messages reduce cognitive load. Poor ones force reading diffs and guessing intent.

### Collaboration and history hygiene

In team environments you’ll often scan many commits. Consistent, clear messages make scanning faster; inconsistent or vague ones slow you down.

### Best-practice reflectiveness

Writing good commit messages forces you to reflect: Did I change only one logical thing? Is this commit “atomic”? If you struggle to succinctly summarise, maybe you bundled too many changes.

---

## Structure of a Commit Message

A popular convention divides the message into three parts:

```
<subject line>

<body (optional)

<footer (optional)>
```

### Subject line

* One line, succinct summary of the change.
* Use **imperative mood** (see section 4).
* No trailing period.
* Ideally ≤ 50 characters.

### Blank line separates subject from body

This blank line helps tools and humans distinguish summary from details.

### Body (optional)

Used when further explanation is warranted. The body should answer:

* What changed?
* Why the change was necessary?
* What impact will it have (or what side-effects)?

It should *not* describe line-by-line “how” the change was implemented (the diff does that).
Wrap lines at approx 72 characters for readability.

### Footer (optional)

Used for metadata: issue or ticket references (e.g., “Closes #123”), breaking‐change notices, acknowledgements. Some conventions treat this formally.

---

## Tone, verb-form and language guidelines

### Imperative mood

Subject lines should read like a command: “Add feature”, “Fix bug”. For example:

> “If applied, this commit will fix the fencepost error.”
> This style aligns with Git’s default autogenerated messages.

### Present tense, not past tense

Good: “Fix buffer overflow”.
Bad: “Fixed buffer overflow” or “Fixes buffer overflow”.
Imperative + present tense = action on applying the commit.

### Capitalisation and punctuation

* Capitalise first word of subject.
* Do **not** end subject line with a period.
* The body may use regular sentence punctuation.

### Clarity over cleverness

Avoid jokes, slang, overly generic terms. Subject must convey what changed; body must supply why.

---

## Recommended conventions and types

### Commit “types”

Some teams adopt prefixes to classify commit purpose. For example the Conventional Commits specification defines types like: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`.
Example:

```
feat(api): add user authentication middleware
```

* `feat`: new feature added
* `fix`: bug fix
* `docs`: documentation only
* `style`: formatting, no code logic change
* `refactor`: code change that neither adds a feature nor fixes a bug
* `test`: adding or updating tests
* `chore`: build/config changes, support tasks

### Scope (optional)

You may include a scope in parentheses to specify the subsystem/module: `fix(ui): adjust button spacing`. Conventional Commits support this.

### Footers for breaking changes and issue refs

If a change breaks backward compatibility you can indicate it either via `!` in the header or via `BREAKING CHANGE:` footer. Conventional Commits standardises this.

Example:

```
feat(api)!: remove deprecated endpoints

BREAKING CHANGE: endpoints /v1/users and /v1/orders are removed.
```

---

## Example commit messages

### Simple change (no body required)

```
Update README with installation instructions
```

### Medium complexity (with body)

```
fix(cache): clear expired entries after read operations

Previously the cache module never removed expired entries at
read time, which caused memory usage to grow unbounded when
idle objects accumulated.

Closes #102
```

### New feature with scope and footer

```
feat(auth): implement OAuth2 login flow

Include endpoints: /auth/login, /auth/callback. Store access
and refresh tokens and refresh automatically when expired.

BREAKING CHANGE: session tokens have been replaced with JWTs.
Refs: #215
```

---

## Additional notes and best practices

* **Commit often**: smaller commits are easier to summarise, review, and revert.
* **One change per commit**: avoid bundling unrelated changes (e.g., formatting + feature + test) in a single commit.
* **Review your message**: after writing it, ask: “Will someone reading this in 6 months understand why I made this change?”
* **Automate if possible**: use git hooks or commit-lint tools to enforce your style.
* **When in doubt match your team / project style**: consistency beats perfection.
* **Avoid redundant phrases**: e.g., “Fix issue where …” → better: “Fix null pointer in user service”. Be direct.

---
